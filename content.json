{"posts":[{"title":"terminology","text":"常用术语。车载领域 IDLFranca IDL: Interface Definition Language. 接口定义语言，fidl 汽车: automotive燃油车的三大件：发动机，变速箱和底盘电车的几大核心：电池，电机，电控和底盘 commonOEM: Original Equipment Manufacturer. 整车厂：宝马，蔚小理Tier1: 一极供应商：博世 SoC: System on Chip. 片上系统，座舱芯片，通常有高通 8155，8295 ESP: Electronic Stability Program. 车身电子稳定控制系统EBD: Electrical Brake Distribution. 电子刹车分配力系统ABS: Antilock Brake System. 防抱死制动系统TCS: Traction Control System. 循迹控制系统VDC: Vehicle Dynamic Control. 车辆动态控制系统 HU: Head UnitBCM: Body Control Module 车身控制模块。例如车窗，门锁等等 EMS: Engine Mangement System. 发动机管理系统（燃油车） VCU: Vehicle Control Unit. 整车控制器（电车） HCU: Hybrid Control Unit. 混动车 GNSS: Global Navigation Satellite System. 全球卫星导航系统。有 GPS，北斗 T-BOX: telematic box. 负责车联网的通信组件 燃油车 TCU: Transmision Control Unit. 自动变速箱控制单元 电车 BMS: Battery Management System. 电池管理系统 协议软件BSW: basic software ODX(ISO 22901-1:2008): Open Diagnostic Data Exchange. （车辆）开放式诊断数据交换协议 PDX: 诊断OBD: On Board Diagnostics 口，通常在主驾舱下方，用来诊断 以太网some/ip dds doip 功能安全 主动安全 被动安全 ASIL: Automotive Safety Integrity Level. autosaraas: Adaptive Autosar cas: classic Autosar IVI: in vehicle infotainment 组织COVESA(前身是 GENIVI): Connected Vehicle Systems Alliance。是一个非营利性的汽车行业联盟，致力于开发集成网联汽车中的操作系统和中间件以及相关云服务的参考方法。开发了知名的 vsomeip, capi, dlt 等 github 地址 部件MCU: Micro Controller Unit 微控制单元 -&gt; ECU: Electronic Control Unit 电子控制单元，通常放在铝盒里 自动驾驶 autonomous drivingTOPS: Tera Operations Per Second。一秒钟进行一万亿次 10^12 次方 英伟达 orin -&gt; thor CC(CCS): Cruise Control (System). 定速巡航（保持定速行驶） ACC(ACCS): Adaptive Cruise Control (System). 自适应巡航 LCC(LCCS): Intelligent Cruise Control (System). 智能领航系统 LKA: Lane Keeping Assist. 车道保持辅助 AEB: Autonomous Emergency Braking. 自动紧急制动 软件工程backward compatibility 向后兼容，回溯兼容。兼容旧版本 forward compatibility 向前兼容，前瞻兼容。考虑未来还能不能用 E2E: exchange to exchange E2E test: end to end test SMP (Symmetric multiprocessing) : 对称多处理","link":"/2024/05/16/terminology/"},{"title":"嵌入式环境","text":"compile qemu gdb 通常来说，供应商或者公司内部一般会提供交叉编译环境的 sdk，用来统一库版本、开发环境。Yocto 是其中一个可以客制化配置 linux 比较通用的工具，其中也制作了交叉环境下的工具链，下面提到的 poky 环境就是用 Yocto 制作出来的。不特别说明的环境则是在 Ubuntu 20.04.6 LTS 环境下 cross compile environment交叉环境下的命名前缀一般遵循 arch-vender-os- 1234567$ whereis riscv64-linux-gnu-gccriscv64-linux-gnu-gcc: /usr/bin/riscv64-linux-gnu-gcc /usr/share/man/man1/riscv64-linux-gnu-gcc.1.gz$ riscv64-linux-gnu-gcc main.c -o main -g# 在 poky 环境下$ whereis aarch64-poky-linux-g++/opt/cross/sysroots/x86_64-pokysdk-linux/usr/bin/aarch64-poky-linux/aarch64-poky-linux-g++ qemu-L 指定 sysroot 1qemu-riscv64 -L /usr/riscv64-linux-gnu ./main gdb cross debuging1234567891011121314# 1. 启动 gdbserver 等待远程连接, 1234 为默认端口$ qemu-riscv64 -L /usr/riscv64-linux-gnu -g 1234 ./main# 2. 使用本地的 gdb 去远程连接，gdb-multiarch 是支持多种架构的 gdb$ gdb-multiarch ./main(gdb) set architecture riscv:rv64(gdb) target remote localhost:1234# 2. 在 poky 环境下# 一般来说 poky 环境下的 sdk 都已经配置好了，如下# This GDB was configured as &quot;--host=x86_64-pokysdk-linux --target=aarch64-poky-linux&quot;.$ aarch64-poky-linux-gdb ./main(gdb) target remote localhost:1234","link":"/2024/07/02/embedded/environment/"},{"title":"yocto","text":"","link":"/2024/07/02/embedded/yocto/"},{"title":"levelDb","text":"slice不包含 ‘\\0’ statusuint32_t len, code, error message 0 ~ 3, 4, [5,)","link":"/2022/08/28/draft/levelDb/"},{"title":"Redis","text":"release: latest data structure sds in redissds: simple dynamic string. 类型 sds 的声明为 1typedef char*sds; 为 sds 申请动态内存的时候，申请了一块连续内存，该内存头部包含了 sds 的头部信息，并且维护该头部信息，源码里称为 sds_hdr_var， sds的 header variable 最新版本的 redis 一共实现了五种相似的 sds 结构体，分别为 sdshdr5（不建议使用）， sdshdr8， sdshdr16， sdshdr32， sdshdr64，以 sdshdr5 和 sdshdr8 为例 12345678910struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[];};struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[];}; struct 声明中使用了 GNU C 编译器的结构体注释，放弃编译器对字节对齐的优化； 变量 flags 中 3 lsb (低三位) 表示了该结构体变量的类型，一共五种，所以只需要低三位； 变量 len 为该 string 已经使用的字符串长度，不包含 C 风格字符串的 ‘\\000’； 变量 alloc 为该 string 分配的字符串长度，包含了 C 风格字符串中的 ‘\\000’， 变量 buf 为空，实际上代表结构体 char *sds 的位置，与头部信息相连。 123456#define SDS_TYPE_5 0#define SDS_TYPE_8 1#define SDS_TYPE_16 2#define SDS_TYPE_32 3#define SDS_TYPE_64 4#define SDS_TYPE_MASK 7 宏变量，方便进行位操作 12#define SDS_TYPE_BITS 3#define SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS) 宏变量，低三位，移位可以获取 type 12#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T)))) 第一个宏函数，声明一个指针 sh，指向 sdshdr##T 类型，sds 变量 s 的指针，该指针指向头部信息 第二个宏函数，同第一个，但不显示声明指针，只是获取地址 通过位操作位偏移操作，可以非常方便的获取 sds 变量的头部信息 12unsigned char flags = s[-1];switch(flags&amp;SDS_TYPE_MASK) 优点保存了 string 信息，二进制安全，同时使用了大量位操作，加快运算。 sds 中保存的实际上是 C 风格字符串，可以使用 C 标准库接口 sds 模块依赖12sds.o: sds.c sds.h sdsalloc.h zmalloc.h \\ ../deps/jemalloc/include/jemalloc/jemalloc.h 依赖为 redis 实现的 zmalloc，zmalloc 是 redis 为 jemalloc 封装的自己内部模块的申请动态内存模块，jemalloc 为优秀的用于高并发用于替代 malloc 的开源库 sdsalloc.h 为 sds 模块与 zmalloc 模块的定义接口文件","link":"/2022/03/18/draft/Redis/"},{"title":"reReadClassicBook","text":"i will read classic book from this month. soft skill[] The Pragmatic Programmer: From Journeyman to Master the C programming language[] the C programming language[]","link":"/2022/08/01/book/reReadClassicBook/"},{"title":"gdb-cpp","text":"gdb 调试 cpp 数据结构的特殊情形 std::string std::vector 对于数据结构更好的调试信息 info pretty-printer std::string1234# 查看元素值## gcc(gdb) p (char *)str(gdb) p str._M_dataplus._M_p[2] std::vector123# 查看元素值## gcc(gdb) p vec._M_impl._M_start[0]","link":"/2024/05/21/gdb/gdb-cpp/"},{"title":"gdb debug 情形讨论一","text":"断在变量特殊值下 我的变量值被谁偷偷改了？ -O2 过度优化可能会导致 No symbol “i” in current context. 调试循环中特定变量的值break point 要打到 brace 里面 123456789#include &lt;iostream&gt;int main(){ for (int i { 0 }; i &lt;= 10; ++i) { // line 5 std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl; // line 6 } return 0;} condition 123(gdb) b test.cpp:6Breakpoint 1 at 0x11b5: file test.cpp, line 5.(gdb) condition 1 i == 5 等同于 1b test.cpp:6 if i == 5 example 2 123456789101112#include &lt;iostream&gt;int main(){ int i = 0; while (i &lt;= 10) { // line 7 std::cout &lt;&lt; &quot;hello, world&quot; &lt;&lt; std::endl; ++i; // line 9 } return 0;} 123456789101112131415(gdb) b test.cpp:9 if i == 6Breakpoint 1 at 0x555555555160: file test.cpp, line 9.(gdb) rStarting program: /home/qxz2lsp/cpp/test hello, worldhello, worldhello, worldhello, worldhello, worldhello, worldBreakpoint 1, main () at test.cpp:77 while (i &lt;= 10) {(gdb) p i$1 = 6","link":"/2024/05/21/gdb/gdb-1/"},{"title":"gdb","text":"gdb cheatsheet commonusage add -g option when compile &lt;Ctrl + l&gt; refresh window docs https://sourceware.org/gdb/onlinedocs/gdb/ https://developer.apple.com/library/archive/documentation/DeveloperTools/gdb/gdb/gdb_6.html set gdb auto run commands when execute gdbgdb main -x .gdbinit write .gdbinit like this 123b main.c:4rp c gdb commandfile main: read file main’s symbol start: enter main function and break b &lt;line number, function name&gt;, breakpoint: add break point c: continue run n: next step s: step into list: list current running several lines p &lt;variable name, expression&gt;: print variable values, expression values bt: print back trace, function call stack information info breakpoints: print break points information info locals: print local variable values info proc map: program memory map @todo help layout: check layout related commandlayout split: split layout in different windowlayout src: show source windowlayout asm: show assemble windowlayout regs: show registers window debug when runningps -elf | grep &lt;executable file&gt;gdb attach &lt;pid&gt; debug in cross compile environmentset sysroot /opt/cross/sysroots/aarch64-poky-linux: set the path of your cross compile system root use gdbserver debug remotely or in different arch@todo debug when crash using coredumpwe need three things before debugging executable file coredump file sdk when cross compile environment generate coredump file, take Ubuntu environment as an exampleUbuntu default configuration(ulimit -c equal 0) will not generate coredump file. we can check by running this command 1ulimit -a output: 12345678910111213141516-t: cpu time (seconds) unlimited-f: file size (blocks) unlimited-d: data seg size (kbytes) unlimited-s: stack size (kbytes) 8192-c: core file size (blocks) 0-m: resident set size (kbytes) unlimited-u: processes 255290-n: file descriptors 1024-l: locked-in-memory size (kbytes) 65536-v: address space (kbytes) unlimited-x: file locks unlimited-i: pending signals 255290-q: bytes in POSIX msg queues 819200-e: max nice 0-r: max rt priority 0-N 15: unlimited then we can change ulimit -c temporarily. only take effect in the current running shell 1ulimit -c unlimited then system will generate coredump file when program crash, but where will we get this file?we can check this 1cat /proc/sys/kernel/core_pattern default setting is here. system will execute apport program report remote when coredump. the coredump file is in the directory /var/lib/apport/coredump/, you can find according to the executable file name, timestamp and so on. 1|/usr/share/apport/apport -p%p -s%s -c%c -d%d -P%P -u%u -g%g -- %E we can change coredump output path by using this command. 1sysctl -w kernel.core_pattern=/tmp/core_%e_%p debug command 1gdb ~/main -c /tmp/core_main_1859038 break point in practice12345(gdb) b mainBreakpoint 1 at 0x243d: file test.cpp, line 57.(gdb) b test.cpp:35Breakpoint 2 at 0x2c6c: file test.cpp, line 35. delete break point 12345678910(gdb) info breakpointsNum Type Disp Enb Address What1 breakpoint keep y 0x000000000000243d in main() at test.cpp:572 breakpoint keep y 0x0000000000002c6c in Solution::minWindow(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) at test.cpp:35(gdb) delete 1(gdb) info breakpointsNum Type Disp Enb Address What2 breakpoint keep y 0x0000000000002c6c in Solution::minWindow(std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;) at test.cpp:35 watch point is also a break point watch command is used to set a watchpoint for writing rwatch for reading awatch for reading/writing.","link":"/2022/05/11/gdb/gdb/"},{"title":"binutils usage","text":"xxd vim %! xxd installUbuntu 1apt install binutils file main objdumpinspect full assembly 1objdump -D &lt;.o&gt; |less 1objdump -S &lt;.o&gt; |less 对源代码和汇编一一对应，要加 -g 选项 readelfreadelf -h hello.o 看 elf header readelf -SW hello.o 看 section header table( W 加变宽，好看一点) readelf -lW main qemu-riscv64 -L /usr/riscv64-linux-gnu ./main qemu-riscv64 -E LD_LIBRARY_PATH=/usr/riscv64-linux-gnu/lib ./main","link":"/2024/06/06/linux/binutils/"},{"title":"ELF file format","text":"ELF (Executable and Linkable Format) wiki: https://en.wikipedia.org/wiki/Executable_and_Linkable_Format ELF header 1readelf -h main.o An ELF file has two views: the program header tables shows the segments used at run time. (runtime view) 1readelf -lW main the section header tables lists the set of sections. (link view) 1readelf -SW main segment is composed of several section with the same (memory flag view ???). in order to save memory since memory alignment caused. symboltake following as an example 12345678910111213#include &lt;stdio.h&gt;int global_init = 0x11111111;const int global_const = 0x22222222;int main(){ static int static_var = 0x33333333; static int static_var_uninit; int auto_var = 0x44444444; printf(&quot;hello world!\\n&quot;); return 0;} readelf -SW main.o 1234567891011121314151617181920212223There are 14 section headers, starting at offset 0x3c8:Section Headers: [Nr] Name Type Address Off Size ES Flg Lk Inf Al [ 0] NULL 0000000000000000 000000 000000 00 0 0 0 [ 1] .text PROGBITS 0000000000000000 000040 000022 00 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 000308 000030 18 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 000064 000008 00 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 00006c 000004 00 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 00006c 000011 00 A 0 0 4 [ 6] .comment PROGBITS 0000000000000000 00007d 00002c 01 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 0000a9 000000 00 0 0 1 [ 8] .note.gnu.property NOTE 0000000000000000 0000b0 000020 00 A 0 0 8 [ 9] .eh_frame PROGBITS 0000000000000000 0000d0 000038 00 A 0 0 8 [10] .rela.eh_frame RELA 0000000000000000 000338 000018 18 I 11 9 8 [11] .symtab SYMTAB 0000000000000000 000108 000198 18 12 12 8 [12] .strtab STRTAB 0000000000000000 0002a0 000068 00 0 0 1 [13] .shstrtab STRTAB 0000000000000000 000350 000074 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) read symbol by readelf -sW main.o 12345678910111213141516171819Symbol table '.symtab' contains 17 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS main.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 6: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 static_var_uninit.2318 7: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_var.2317 8: 0000000000000000 0 SECTION LOCAL DEFAULT 7 9: 0000000000000000 0 SECTION LOCAL DEFAULT 8 10: 0000000000000000 0 SECTION LOCAL DEFAULT 9 11: 0000000000000000 0 SECTION LOCAL DEFAULT 6 12: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init 13: 0000000000000000 4 OBJECT GLOBAL DEFAULT 5 global_const 14: 0000000000000000 34 FUNC GLOBAL DEFAULT 1 main 15: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _GLOBAL_OFFSET_TABLE_ 16: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND puts Ndx means the idx in Nr or use nm nm main.o 12345670000000000000000 R global_const0000000000000000 D global_init U _GLOBAL_OFFSET_TABLE_0000000000000000 T main U puts0000000000000004 d static_var.23170000000000000000 b static_var_uninit.2318 or use objdump objdump -tSw main.o 1234567891011121314151617181920212223242526272829303132333435main.o: file format elf64-x86-64SYMBOL TABLE:0000000000000000 l df *ABS* 0000000000000000 main.c0000000000000000 l d .text 0000000000000000 .text0000000000000000 l d .data 0000000000000000 .data0000000000000000 l d .bss 0000000000000000 .bss0000000000000000 l d .rodata 0000000000000000 .rodata0000000000000000 l O .bss 0000000000000004 static_var_uninit.23180000000000000004 l O .data 0000000000000004 static_var.23170000000000000000 l d .note.GNU-stack 0000000000000000 .note.GNU-stack0000000000000000 l d .note.gnu.property 0000000000000000 .note.gnu.property0000000000000000 l d .eh_frame 0000000000000000 .eh_frame0000000000000000 l d .comment 0000000000000000 .comment0000000000000000 g O .data 0000000000000004 global_init0000000000000000 g O .rodata 0000000000000004 global_const0000000000000000 g F .text 0000000000000022 main0000000000000000 *UND* 0000000000000000 _GLOBAL_OFFSET_TABLE_0000000000000000 *UND* 0000000000000000 putsDisassembly of section .text:0000000000000000 &lt;main&gt;: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: c7 45 fc 44 44 44 44 movl $0x44444444,-0x4(%rbp) 13: 48 8d 3d 00 00 00 00 lea 0x0(%rip),%rdi # 1a &lt;main+0x1a&gt; 1a: e8 00 00 00 00 callq 1f &lt;main+0x1f&gt; 1f: 90 nop 20: c9 leaveq 21: c3 retq objdump -s -j .rodata main.o 12345main.o: file format elf64-x86-64Contents of section .rodata: 0000 22222222 68656c6c 6f20776f 726c6421 &quot;&quot;&quot;&quot;hello world! 0010 00 sectionrpath: custom dynamic library path readelf -d build/Demo 10x000000000000001d (RUNPATH) Library runpath: [/home/heli/project/Demo/build/components/hello] objdump -x build/Demo | grep RUNPATH 1RUNPATH /home/heli/project/Demo/build/components/hello","link":"/2024/06/06/linux/elf/"},{"title":"self configuration in linux","text":"install123apt install build-essentialecho $PATH bachrc12345678# gitalias mgs=&quot;git status&quot;alias mgc=&quot;git commit&quot;alias mgca=&quot;git commit --amend&quot;# cmakealias mcmakec=&quot;rm -rf build &amp;&amp; cmake -S . -B build&quot;alias mcmakeb=&quot;cmake --build build --parallel 32 &quot; ssh related1234567891011121314151617# generate ssh key pairssh-keygen -t ed25519 -C helianthus547@gmail.com# login without passwordssh-copy-id -i ~/.ssh/id_ed25519.pub heli@192.168.1.113# login without server information aliasvim ~/.ssh/configHost WS HostName 192.168.1.113 Port 22 User heli IdentityFile ~/.ssh/id_ed25519# verify git can ssh usessh -T git@github.com change to nerd font1234567891011121314apt install -yqq fontconfigwget -q -nv https://github.com/ryanoasis/nerd-fonts/releases/download/v3.2.1/JetBrainsMono.zipunzip JetBrainsMono.zip -d ~/.local/share/fontsfc-cache -fv# macbook brew search fontbrew install font-jetbrains-mono-nerd-font# vscode'JetbrainsMonoNL Nerd Font Mono' tar1234567# zip## -c createtar -zcvf xxx.tar.gz source_file# unzip## -x extracttar -zxvf xxx.tar.gz -C path big or little endianlscpu 123456789101112#include &lt;bit&gt;#include &lt;iostream&gt; int main(){ if constexpr (std::endian::native == std::endian::big) std::cout &lt;&lt; &quot;big-endian\\n&quot;; else if constexpr (std::endian::native == std::endian::little) std::cout &lt;&lt; &quot;little-endian\\n&quot;; else std::cout &lt;&lt; &quot;mixed-endian\\n&quot;;} 123456789101112union T { int i; char byte[];} t;int main(){ t.i = 1; t.byte[0] == 1; return }","link":"/2024/06/06/linux/configuration/"},{"title":"main 函数的启动流程","text":"本文简单探讨一下 main 函数的启动流程 环境搭建测试环境为 arch linux, x86 ISA，使用 docker 新建 Ubuntu 容器 1sudo docker run -it --name test ubuntu 在容器中 1cd ~ &amp;&amp; apt update &amp;&amp; apt install -y build-essential vim gdb less vim main.c，编写 main.c 源文件 1234567#include &lt;stdio.h&gt;int main(void){ printf(&quot;hello, world\\n&quot;); return 0;} gcc -g main.c -o main 读取 main 可执行程序123456789101112131415161718192021root@479c0e77cdf2:~# readelf -h mainELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Position-Independent Executable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x1060 Start of program headers: 64 (bytes into file) Start of section headers: 13976 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 13 Size of section headers: 64 (bytes) Number of section headers: 31 Section header string table index: 30 请注意 Entry point address 的地址为 0x1060，程序入口地址 1objdump -D main |less 查找程序入口地址 1060，可以看到如下 123456789101112131415161718192021222324252627282930313233Disassembly of section .text:0000000000001060 &lt;_start&gt;: 1060: f3 0f 1e fa endbr64 1064: 31 ed xor %ebp,%ebp 1066: 49 89 d1 mov %rdx,%r9 1069: 5e pop %rsi 106a: 48 89 e2 mov %rsp,%rdx 106d: 48 83 e4 f0 and $0xfffffffffffffff0,%rsp 1071: 50 push %rax 1072: 54 push %rsp 1073: 45 31 c0 xor %r8d,%r8d 1076: 31 c9 xor %ecx,%ecx 1078: 48 8d 3d ca 00 00 00 lea 0xca(%rip),%rdi # 1149 &lt;main&gt; 107f: ff 15 53 2f 00 00 call *0x2f53(%rip) # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt; 1085: f4 hlt 1086: 66 2e 0f 1f 84 00 00 cs nopw 0x0(%rax,%rax,1) 108d: 00 00 000000000000001140 &lt;frame_dummy&gt;: 1140: f3 0f 1e fa endbr64 1144: e9 77 ff ff ff jmp 10c0 &lt;register_tm_clones&gt;0000000000001149 &lt;main&gt;: 1149: f3 0f 1e fa endbr64 114d: 55 push %rbp 114e: 48 89 e5 mov %rsp,%rbp 1151: 48 8d 05 ac 0e 00 00 lea 0xeac(%rip),%rax # 2004 &lt;_IO_stdin_used+0x4&gt; 1158: 48 89 c7 mov %rax,%rdi 115b: e8 f0 fe ff ff call 1050 &lt;puts@plt&gt; 1160: b8 00 00 00 00 mov $0x0,%eax 1165: 5d pop %rbp 1166: c3 ret _start 的地址 0000000000001060 main 函数实现的地址如下 0000000000001149 __libc_start_main 为 glibc 动态库的桩代码 我们逐步分析 _start 主要做了什么 1060 启用 RAI (Return Address Indirection) 技术1064 清零 ebp 基址寄存器1066 将通用寄存器 rdx 拷贝到 r9 中1069 从栈上 pop 一个值给 rsi106a 栈顶指针 rsp 拷到 rdx 中106d rsp 和 16 字节向下对齐1071 push rax1072 push rsp1073 清零 r8d1076 清零 rcx1078 rdi 的值为 rip + 0xca107f 跳到 0x2f53 + rip 的地址 很难看明白，还是用 gdb 看 glibc 到底做了什么 安装 glibc-6以下我们可以发现 main 被链接到 glibc-6 的版本 1234root@479c0e77cdf2:~# ldd main linux-vdso.so.1 (0x00007ffeb53c7000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f79e99b7000) /lib64/ld-linux-x86-64.so.2 (0x00007f79e9bea000) 为了更近一步分析，我们需要 glibc-6 的源码，下载源码或者在 /etc/apt/sources.list.d/ubuntu.sources 添加以下内容 12345Types: deb-srcURIs: http://archive.ubuntu.com/ubuntu/Suites: noble noble-updates noble-backportsComponents: main universe restricted multiverseSigned-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg 更新源和源码 1apt update &amp;&amp; apt source libc6 发现当前文件夹有了 glibc-2.39 的源码文件 编写 .gdbinit 文件，填源文件搜索路径 123dir ~/glibc-2.39b _startr gdb main -x .gdbinit 12345678b _dl_start_userb _dl_initb call_initb _init_firstb __init_miscb __libc_start_main_implb __libc_start_call_main _dl_start_user 是 ld 动态库 分析_init_first __init_misc __libc_start_main_impl __libc_start_call_main 这三个函数都做了什么呢？@todo","link":"/2024/04/29/linux/inside-main/"},{"title":"Docker","text":"docker cheatsheet imagespull image 1docker pull ubuntu:latest remove image, must delete containers use this image 1docker rmi plctlab build image by Dockerfile 1sudo docker build -t plctlab . 1234567891011121314151617FROM ubuntu:latest# proxy settings according to the host ip and portENV PROXY_IP=192.168.5.38ENV PROXY_PORT=7890ENV http_proxy=http://$PROXY_IP:$PROXY_PORTENV https_proxy=http://$PROXY_IP:$PROXY_PORTENV all_proxy=socks5://$PROXY_IP:$PROXY_PORTRUN apt update &amp;&amp; apt install -y build-essential gcc make perl dkms git gcc-riscv64-unknown-elf gdb-multiarch qemu-system-miscWORKDIR /rootRUN git clone https://github.com/plctlab/riscv-operating-system-mooc.git# execute when container startCMD [&quot;bash&quot;] containercreate container 12docker run -it --name my-ubuntu ubuntu:latest /bin/bashdocker run -it --name my-ubuntu ubuntu:20.04 /bin/bash exit 后容器会退出运行 -d 后台运行 –rm 退出后自动删除容器 删除1docker rm my-ubuntu 查看1234# 查看运行的容器docker ps# 查看所有包括退出的容器docker ps -a 继续运行12docker start my-ubuntudocker exec -it my-ubuntu /bin/bash attach 容器12sudo docker start my-ubuntusudo docker attach my-ubuntu equals 1sudo docker start -i my-ubuntu port mapping(&lt;host port&gt;:&lt;container port&gt;), file volume(&lt;host directory&gt;:&lt;container directory&gt;)docker run -it -p 8999:4000 -v ~/arch:/root/host –name heli archlinux /bin/bash formal C-S 架构，C 端为 Docker 或者 Docker Compose，S 端为 Docker daemon To build your own image, you create a Dockerfile with a simple syntax for defining the steps needed to create the image and run it. Each instruction in a Dockerfile creates a layer in the image. When you change the Dockerfile and rebuild the image, only those layers which have changed are rebuilt. This is part of what makes images so lightweight, small, and fast, when compared to other virtualization technologies. When running a container, it uses an isolated filesystem. This custom filesystem is provided by a container image. Since the image contains the container’s filesystem, it must contain everything needed to run an application - all dependencies, configuration, scripts, binaries, etc. The image also contains other configuration for the container, such as environment variables, a default command to run, and other metadata. containers: 可以定义network, storage 创建 imagesudo docker build -t // tag 取 image 的名字 . // 选择 Dockerfile 目录 运行 containersudo docker run -i // interactively -t // attach to your terminal ubuntu // ubuntu 是 image 名字 /bin/bash // command sudo docker run -d // detached 模式分离 -p 3000:3000 // Without the port mapping, we wouldn’t be able to access the application. port mapping 左边是本机的 3000 端口映射到容器的 3000 端口上 修改容器sudo docker ps -a sudo docker stop container-id sudo dokcer rm container-id sudo docker rm -f container-id // by force pushdocker login -u USER-NAMEdocker tag local-image:tagname // 为本地当前已有的 image 起别名, 也可以使用 repo 的名字, tagname 不指定即是 latest 的 tag，本身使用的是相同的 image id，但是是不同的 REPOSITORY new-repo:tagnamedocker push new-repo:tagname example远程库名字为 love1angel/getting-starteddocker tag hello love1angel/getting-started:1.1docker push love1angel/getting-started:1.1 下面命令如果本地没有 latest 标签，就会报错docker push love1angel/getting-started filesystemWhen a container runs, it uses the various layers from an image for its filesystem. Each container also gets its own “scratch space 暂存空间” to create/update/remove files. Any changes won’t be seen in another container, even if they are using the same image. docker run -d ubuntu bash -c “shuf -i 1-10000 -n 1 -o /data.txt &amp;&amp; tail -f /dev/null”docker exec container-id cat /data.txtdocker run -it ubuntu ls / Volumes provide the ability to connect specific filesystem paths of the container back to the host machine. If a directory in the container is mounted, changes in that directory are also seen on the host machine. If we mount that same directory across container restarts, we’d see the same files. named volumes $ docker volume create todo-db 在/etc/todos/todo.db底下，mount it to，-v flag to specify a volume mount. $ docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started While named volumes and bind mounts (which we’ll talk about in a minute) are the two main types of volumes supported by a default Docker engine installation, there are many volume driver plugins available to support NFS, SFTP, NetApp, and more! This will be especially important once you start running containers on multiple hosts in a clustered environment with Swarm, Kubernetes, etc. docker volume inspect todo-db bind-mountWhen working on an application, we can use a bind mount to mount our source code into the container to let it see code changes, respond, and let us see the changes right away. Mount our source code into the containerInstall all dependencies, including the “dev” dependenciesStart nodemon to watch for filesystem changes docker run -dp 3000:3000 -w /app -v “$(pwd):/app” node:12-alpine sh -c “yarn install &amp;&amp; yarn run dev” -dp 3000:3000 - same as before. Run in detached (background) mode and create a port mapping-w /app - sets the “working directory” or the current directory that the command will run from-v “$(pwd):/app” - bind mount the current directory from the host in the container into the /app directorynode:12-alpine - the image to use. Note that this is the base image for our app from the Dockerfilesh -c “yarn install &amp;&amp; yarn run dev” - the command. We’re starting a shell using sh (alpine doesn’t have bash) and running yarn install to install all dependencies and then running yarn run dev. If we look in the package.json, we’ll see that the dev script is starting nodemon. docker logs -f docker build -t getting-started . 去运行容器，此时已变成更改后的 Using bind mounts is very common for local development setups. The advantage is that the dev machine doesn’t need to have all of the build tools and environments installed. With a single docker run command, the dev environment is pulled and ready to go. 7the container only starts one process If two containers are on the same network, they can talk to each other. If they aren’t, they can’t. There are two ways to put a container on a network: 1) Assign it at start or 2) connect an existing container. docker network create todo-app docker run -d –network todo-app –network-alias mysql -v todo-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=secret -e MYSQL_DATABASE=todos mysql:5.7 https://hub.docker.com/_/mysql/ Dockerfile CMD [“node”, “src/index.js”] The CMD directive specifies the default command to run when starting a container from this image.","link":"/2022/03/18/tools/Docker/"},{"title":"adas","text":"MDF4: 文件格式parquet: 文件格式pickle: 文件格式 recall: 召回precision: 精度 SLAM (Simultaneous Localization And Mapping) : 同时定位与地图构建IMU (Inertial Measurement Unit) : 惯性测量单元 Blob (Binary large object) : 二进制大型对象，如图像 Monocular: 单目相机 Stereo: 双目相机 RGB-D: 深度相机 motion: 运动landmark: 路标 rotation: 旋转translation: 平移 Geometry: 几何学 degree: 方向盘转向角度velocity: 速度 acceleration: 加速度 - lateral direction: 横向 - longitudinal direction: 纵向 quantized model: 量化模型fine tuningtunnelsroad cluster 物体识别 2D, 3D物体跟踪物体检测语义分割","link":"/2024/06/24/terminology/adas/"},{"title":"Markdown","text":"What is Markdown?Markdown 是一种轻量级的文本标记写法（markup language），广泛用于 GitHub，博客等各种 Web 网站。Markdown guide 网站源码：GitHub，网站教程已经写的很好，本文借鉴于此，做个笔记 原理处理 markdown 文件的应用程序使用一种称为 Markdown 处理器，也叫解析器或者实现的东西将该格式文件转换为 HTML, 再通过 Web 浏览器进行显示 Why use Markdown? easy to learn, use, light-weight place emphasis on content, not mark format can be transfer into html or other format, easy for distribution 微软的 word 等软件太生草了，写的时候纠结于格式，打开还要下载特定的软件，不适合到处纷发这种特性，Markdown 注重的是写作的内容而不是格式问题 Markdown 可以内嵌 HTML 语法，许多网站内嵌 Markdown 处理器，适合现在 Web 浏览器显示 生成 GitHub PagesGitHub 为 Jekyll 提供免费的网页 host 服务 GitHub Pages uses Jekyll as the backend for its free website creation service 其他可用的静态网站生成器 如果您想使用内容管理系统（CMS）来为网站提供动力，请查看Ghost。这是一个免费的开源博客平台，具有出色的Markdown编辑器。如果您是WordPress用户，您将很高兴知道WordPress.com上托管的网站有Markdown支持。自托管的WordPress网站可以使用Jetpack插件。 How to use Markdown?Basic Syntax 标题 12345678# 标题or&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;段落之间空行，且不要缩进。用 &amp;nbsp;&lt;p&gt;&lt;/p&gt;&lt;br&gt; 粗体 123**bold**or&lt;strong&gt;&lt;/strong&gt; 斜体 123*italic*or&lt;em&gt;&lt;/em&gt; 块引用 123456&gt; blockquote&gt;&gt; two之间空行&gt; ###&gt;&gt; - 有序列表 12345678910111. ordered list2. two&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt;1968\\. 转义在列表中通过缩进四个空格来添加其他元素 无序列表 12345- unordered list&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; code 123`code`&lt;code&gt;&lt;/code&gt;``Use `code` in your Markdown file.`` 水平线 horizontal rule 12---之间空行 链接 123456789101112131415[title](link address &quot;悬停提示&quot;)直接显示链接&lt;https://www.markdownguide.org&gt;&lt;fake@example.com&gt;I love supporting the **[EFF](https://eff.org)**.This is the *[Markdown Guide](https://www.markdownguide.org)*.See the section on [`code`](#code).&lt;a href=&quot;&quot; title=&quot;&quot;&gt;link&lt;/a&gt;与原来的链接一样，1 为 1 的链接[hobbit-hole][1][1]: https://en.wikipedia.org/wiki/Hobbit#Lifestyle &quot;Hobbit lifestyles&quot;Markdown 中链接如果有空格用%20代替，否则用 HTML 的 tag 图片 123![alt 不显示的时候](image.jpg &quot;title&quot;)[![An old rock in the desert](/assets/images/shiprock.jpg &quot;Shiprock, New Mexico by Beau Rogers&quot;)](https://www.flickr.com/photos/) 块级元素之间分行，尽量不要缩进 tag，会干扰格式，且不能在块级元素使用 Markdown 语法，不会工作 \\进行转义 Extended SyntaxGitHub Flavored Markdown (GFM) 表格 table 12345| class | name | test ||:------|:----:|-----:|| 1 | 2 | \\| || 可以用 &amp;#124; 表中可以用 HTML 语法加入 list 代码块 fenced code block 1234567```json{ &quot;firstname&quot;: &quot;John&quot;, &quot;lastname&quot;: &quot;Smith&quot;, &quot;age&quot;: 25}\\`\\`\\` 脚注 footnote 123456789101112可以添加标识符，但实际上仍然是按顺序标号Here's a simple footnote,[^1] and here's a longer one.[^bignote][^1]: This is the first footnote.[^bignote]: Here's one with multiple paragraphs and code. Indent paragraphs to include them in the footnote. `{ my code }` Add as many paragraphs as you like. 标题 ID heading ID 12345### My Great Heading {#custom-id}&lt;h3 id=&quot;custom-id&quot;&gt;My Great Heading&lt;/h3&gt;[Heading IDs](#heading-ids)&lt;a href=&quot;#heading-ids&quot;&gt;Heading IDs&lt;/a&gt;[Heading IDs](https://www.markdownguide.org/extended-syntax#heading-ids) 定义列表 definition list 123456789101112131415term: definitionFirst Term: This is the definition of the first term.Second Term: This is one definition of the second term.: This is another definition of the second term.&lt;dl&gt; &lt;dt&gt;First Term&lt;/dt&gt; &lt;dd&gt;This is the definition of the first term.&lt;/dd&gt; &lt;dt&gt;Second Term&lt;/dt&gt; &lt;dd&gt;This is one definition of the second term. &lt;/dd&gt; &lt;dd&gt;This is another definition of the second term.&lt;/dd&gt;&lt;/dl&gt; 删除线 strikethrough 1~~The world is flat.~~ 任务列表 task list 12- [x]- [ ] 表情 emoji Emojipedia list of emoji shortcodes 1That is so funny! :joy: 高亮 highlight 12I need to highlight these ==very important words==.&lt;mark&gt;&lt;/mark&gt; 下标 subscript 12H~2~0&lt;sub&gt;2&lt;/sub&gt; 上标 superscript 12X^2^&lt;sup&gt;2&lt;/sup&gt; diable automatic URL linking 1`http://www.example.com` Hacks123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# 下划线 underline&lt;ins&gt;&lt;/ins&gt;# indent(Tab)&amp;nbsp; non-breaking space# center&lt;p style=&quot;text-align:center&quot;&gt;Center this text&lt;/p&gt;# color&lt;p style=&quot;color:blue&quot;&gt;Make this text blue.&lt;/p&gt;# comment[This is a comment that will be hidden.]: ## 告诫 admonitions&gt; :warning: **Warning:** Do not push the big red button.&gt; :memo: **Note:** Sunrises are beautiful.&gt; :bulb: **Tip:** Remember to appreciate the little things in life.# image size&lt;img src=&quot;image.png&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;# 图像说明 image captions&lt;figure&gt; &lt;img src=&quot;/assets/images/albuquerque.jpg&quot; alt=&quot;Albuquerque, New Mexico&quot;&gt; &lt;figcaption&gt;A single track trail outside of Albuquerque, New Mexico.&lt;/figcaption&gt;&lt;/figure&gt;or![Albuquerque, New Mexico](/assets/images/albuquerque.jpg)*A single track trail outside of Albuquerque, New Mexico.*# link target&lt;a href=&quot;https://www.markdownguide.org&quot; target=&quot;_blank&quot;&gt;Learn Markdown!&lt;/a&gt;# symbolsCopyright (©) — &amp;copy;Registered trademark (®) — &amp;reg;Trademark (™) — &amp;trade;Euro (€) — &amp;euro;Left arrow (←) — &amp;larr;Up arrow (↑) — &amp;uarr;Right arrow (→) — &amp;rarr;Down arrow (↓) — &amp;darr;Degree (°) — &amp;#176;Pi (π) — &amp;#960;# table 里的元素&lt;br&gt;list# table of contents- [Underline](#underline)- [Indent](#indent)- [Center](#center)- [Color](#color)# videoYouTube automatically generates an image for every video (https://img.youtube.com/vi/YOUTUBE-ID/0.jpg), so we can use that and link the image to the video on YouTube. After we replace the image alt text and add the ID of the video, our example looks like this:[![Less Than Jake — Scott Farcas Takes It On The Chin](https://img.youtube.com/vi/PYCxct2e0zI/0.jpg)](https://www.youtube.com/watch?v=PYCxct2e0zI)","link":"/2022/03/19/tools/Markdown/"},{"title":"git","text":"本文主要记录 git 使用。submodule 正常使用origin 为代号，可以随意取 1234# https 方式git remote add origin https://github.com/love1angel/testgit.git# ssh 方式git remote add origin git@github.com:love1angel/testgit.git submodule 使用创建123mkdir 3rdpartycd 3rdpartygit submodule add https://github.com/google/googletest.git 下载12git submodule initgit submodule update --recursive 查看状态1234567891011# 正常下载好的状态git submodule status 33af80a883ddc33d9c0fac0a5b4578301efb18de 3rdparty/googletest (release-1.8.0-3471-g33af80a8)# 如果没有下好，带 -git submodule status-2954cb8d879886403d55343f941ae7d0216e0f6b 3rdparty/googletest# 有更新，带 +git submodule status+33af80a883ddc33d9c0fac0a5b4578301efb18de 3rdparty/googletest (release-1.8.0-3471-g33af80a8) 更新12345678910# 更新总仓库目前的分支，引用git remote update# 更新到总仓库git submodule update --recursive# 更新子仓库到最新的提交git submodule update --remote# 更新单个仓库git submodule update --remote 3rdparty/googletest before no usegit使用目的：Linus为了管理Linux源码用C语言开发的分布式版本控制系统类型：分布式分布式 VS 集中式 集中式：CVS和SVN等 分布式：git等 集中式通常也有一台充当中央服务器的电脑，主要是为了方便交换大家的修改 集中式的缺点 版本库集中存放在中央服务器，需要联网获得最新的版本 只有一个中央服务器可能会宕机，导致所有人无法工作 中央服务器的版本库一旦出现存在问题，难以补救，不安全 let’s start:)准备 download git 设置本机的user信息，本机所有repository都会使用这个配置，对单独的仓库也可以单独设置，通过git config命令查看参数选项 12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;email@example.com&quot; 查看本地global参数 1$ git config --list --global !!! 修改global参数后以前的提交还是以前的user参数，???git repository如何识别user呢 初始化一个仓库，会在当前目录添加一个隐藏目录(.git) 1$ git init !!! git 只能跟踪文本文件的改动，图片、视频这些二进制文件，没法跟踪文件的变化 changes not staged for commit untracked changes -&gt; staged changes(update what will be committed) 1$ git add &lt;files&gt; discard changes in working directory(将工作区的状态回到暂存区的状态) 1$ git checkout -- &lt;files&gt; 要提交的变更 staged changes -&gt; untracked changes(将暂存区会退到到head所指的分支，并把暂存区的修改回退到工作区) 1$ git reset HEAD &lt;files&gt; 提交 1$ git commit -m &quot;&quot; 查看repository的状态 查看过去日志 1$ git log 查看当前状态 1$ git status 版本控制 回到过去(之前的修改保存到untracked changes，暂存区也回退) 12$ git reset HEAD^$ git reset HEAD~1 强制回退，可以通过commitID在回去，丢弃所有目前的修改，不建议用 12$ git reset --hard HEAD^$ git reset --hard 7f1f 查看命令历史，回到未来 1$ git reflog 管理修改 比较工作区和HEAD指针所指向的分支 1$ git diff 远程库1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 本地仓库关联远程仓库 1234567891011121314151617181920# 测试一下ssh-key添加是否成功$ ssh -T git@github.com# 关联远程仓库，本地取名叫origin$ git remote add origin https://github.com/love1angel/work.git# 查看本地分支，即可查看远程分支remotes/origin/main$ git branch -a# 将本地分支master重命名为main分支$ git branch -M main# 第一次push main分支，远程库会创建main分支，同时将本地main分支push到orgin的main分支，-u参数会将本地的main分支与远程的main分支关联起来$ git push -u origin main# 直接push main分支到origin$ git push origin main# 远程库$ git remote -v# 删除远程库联系$ git remote rm origin# 使用clone会自动关联远程库$ git clone 分支管理创建合并分支123456789101112131415# 新建分支并切换$ git checkout -b dev# equals to$ git branch dev$ git checkout dev# 检查一下$ git branch# 将dev分支合并到master分支$ git merge dev# 删除分支$ git branch -d dev 冲突解决123456789101112# 合并分支时出现冲突，变化会保存当前分支$ git merge fearture1# 解决冲突后$ git add$ git commit# 解决完成，合并成功，查看一下$ git log --graph## 禁用fast forward，fast forward是直接修改当前指针跳转，看不出来曾经做过合并，禁用会在当前分支新增一个commit$ git merge --no-ff -m &quot;merge with no-ff&quot; dev BUG分支，feature分支12345678910111213# 保存 Saved working directory and index state WIP$ git stash$ git stash list# 恢复指定的$ git stash apply stash@{0}# 删除stash内容$ git stash pop stash@{0}# 在当前分支应用某个commit$ git cherry-pick &lt;commit&gt; 多人开发12345678# 关联本地新建dev分支到远程的dev分支$ git checkout -b dev origin/dev# 有人提交后，与本地有冲突，需要先pull，在本地merge，解决冲突，在推送$ git branch --set-upstream-to=origin/&lt;branch-name&gt; &lt;branch-name&gt;# 本地两次提交，pull下来一次提高，将本地未push的分叉提交历史拉直$ git rebase tagtag就是某个commit，不过commitID不好记住，且无意义 1234567891011121314$ git tag v1.0$ git tag$ git tag v0.9 f52c633$ git show &lt;tagname&gt;# -a指定标签名字，-m指定说明文字$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb$ git tag -d v0.1$ git push origin v1.0$ git push origin --tags# 删除远程标签$ git tag -d v0.9$ git push origin :refs/tags/v0.9 git个性化定制1$ git config --global color.ui true 创建.gitignore gitignore配置 12345$ git check-ignore -v App.class.gitignore:3:*.class App.class# 不排除.gitignore和App.class:!.gitignore!App.class","link":"/2022/03/21/tools/git/"},{"title":"tmux","text":"tmux cheatsheet sessiontmux new-session -s &lt;sesssion name&gt;: create new session, naming by -s tmux detach, Ctrl + b, d: detach current session tmux attach -t &lt;name, session number&gt;: attach to session name work windowtmux new-window -n &lt;window name&gt;: create new window, naming by -n Ctrl + b, &lt;window number&gt;: select window","link":"/2024/05/17/tools/tmux/"},{"title":"capi","text":"本文主要介绍车载以太网的 CommonAPI 的应用 user guide links GitHub source code repo linksthe step 3 depends on the step 1 the step 1 need to install boost library first like following 1$ sudo apt-get install libboost-all-dev vsomeip capicxx-core-runtime capicxx-someip-runtime code generate toolsthis code generate tools depend on Java environment 1$ sudo apt-get install openjdk-17-jdk CommonAPI core header generate CommonAPI source code generate run helloworldbig three json config file 12345678910111213141516171819202122232425262728293031323334353637{ &quot;unicast&quot;:&quot;local&quot;, &quot;logging&quot;: { &quot;level&quot;:&quot;debug&quot;, &quot;console&quot;:&quot;true&quot; }, &quot;applications&quot;: [ { &quot;name&quot;:&quot;HelloWorldService&quot;, &quot;id&quot;:&quot;0x4444&quot; }, { &quot;name&quot;:&quot;HelloWorldClient&quot;, &quot;id&quot;:&quot;0x5555&quot; } ], &quot;services&quot;: [ { &quot;service&quot;:&quot;0x1111&quot;, &quot;instance&quot;:&quot;0x2222&quot;, &quot;unreliable&quot;:&quot;30509&quot; } ], &quot;routing&quot;:&quot;HelloWorldService&quot;, &quot;service-discovery&quot;: { &quot;enable&quot;:&quot;false&quot; }} HelloWorld.fidl 123456789101112package commonapiinterface HelloWorld { version {major 1 minor 0} method sayHello { in { String name } out { String message } }} HelloWorld.fdepl 12345678910111213141516import &quot;platform:/plugin/org.genivi.commonapi.someip/deployment/CommonAPI-SOMEIP_deployment_spec.fdepl&quot;import &quot;HelloWorld.fidl&quot;define org.genivi.commonapi.someip.deployment for interface commonapi.HelloWorld { SomeIpServiceID = 4660 method sayHello { SomeIpMethodID = 3300 }}define org.genivi.commonapi.someip.deployment for provider as MyService { instance commonapi.HelloWorld { InstanceId = &quot;test&quot; SomeIpInstanceID = 2200 }} then generate code12# ➜ helloworld ../commonapi_core_generator/commonapi-core-generator-linux-x86_64 -sk ./fidl/HelloWorld.fidl➜ helloworld ../commonapi_someip_generator/commonapi-someip-generator-linux-x86_64 -ll verbos ./fidl/HelloWorld.fdepl write your code HelloWorldStubImpl.hpp 123456789101112131415#ifndef HELLOWORLDSTUBIMPL_H_#define HELLOWORLDSTUBIMPL_H_#include &lt;CommonAPI/CommonAPI.hpp&gt;#include &lt;v1/commonapi/HelloWorldStubDefault.hpp&gt;class HelloWorldStubImpl: public v1::commonapi::HelloWorldStubDefault {public: HelloWorldStubImpl(); virtual ~HelloWorldStubImpl(); virtual void sayHello(const std::shared_ptr&lt;CommonAPI::ClientId&gt; _client, std::string _name, sayHelloReply_t _return);};#endif /* HELLOWORLDSTUBIMPL_H_ */ HelloWorldStubImpl.cpp 123456789101112#include &quot;HelloWorldStubImpl.hpp&quot;HelloWorldStubImpl::HelloWorldStubImpl() { }HelloWorldStubImpl::~HelloWorldStubImpl() { }void HelloWorldStubImpl::sayHello(const std::shared_ptr&lt;CommonAPI::ClientId&gt; _client, std::string _name, sayHelloReply_t _reply) { std::stringstream messageStream; messageStream &lt;&lt; &quot;Hello &quot; &lt;&lt; _name &lt;&lt; &quot;!&quot;; std::cout &lt;&lt; &quot;sayHello('&quot; &lt;&lt; _name &lt;&lt; &quot;'): '&quot; &lt;&lt; messageStream.str() &lt;&lt; &quot;'\\n&quot;; _reply(messageStream.str());}; HelloWorldService.cpp 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;CommonAPI/CommonAPI.hpp&gt;#include &quot;HelloWorldStubImpl.hpp&quot;using namespace std;int main() { std::shared_ptr&lt;CommonAPI::Runtime&gt; runtime = CommonAPI::Runtime::get(); std::shared_ptr&lt;HelloWorldStubImpl&gt; myService = std::make_shared&lt;HelloWorldStubImpl&gt;(); bool res = runtime-&gt;registerService(&quot;local&quot;, &quot;test&quot;, myService); // bool res = runtime-&gt;registerService(&quot;192.168.43.133&quot;, &quot;test&quot;, myService); std::cout &lt;&lt; &quot;Successfully Registered Service!&quot; &lt;&lt; std::endl; while (true) { std::cout &lt;&lt; &quot;Waiting for calls... (Abort with CTRL+C)&quot; &lt;&lt; std::endl; std::this_thread::sleep_for(std::chrono::seconds(30)); } return 0;} HelloWorldClient.cpp 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unistd.h&gt;#include &lt;CommonAPI/CommonAPI.hpp&gt;#include &lt;v1/commonapi/HelloWorldProxy.hpp&gt;using namespace v1::commonapi;int main() { std::shared_ptr &lt; CommonAPI::Runtime &gt; runtime = CommonAPI::Runtime::get(); std::shared_ptr&lt;HelloWorldProxy&lt;&gt;&gt; myProxy = runtime-&gt;buildProxy&lt;HelloWorldProxy&gt;(&quot;local&quot;, &quot;test&quot;); // std::shared_ptr&lt;HelloWorldProxy&lt;&gt;&gt; myProxy = runtime-&gt;buildProxy&lt;HelloWorldProxy&gt;(&quot;192.168.43.133&quot;, &quot;test&quot;); std::cout &lt;&lt; &quot;Checking availability!&quot; &lt;&lt; std::endl; while (!myProxy-&gt;isAvailable()) usleep(10); std::cout &lt;&lt; &quot;Available...&quot; &lt;&lt; std::endl; CommonAPI::CallStatus callStatus; std::string returnMessage; while (true) { std::this_thread::sleep_for(std::chrono::seconds(1)); myProxy-&gt;sayHello(&quot;xiepeng&quot;, callStatus, returnMessage); std::cout &lt;&lt; &quot;Got message: '&quot; &lt;&lt; returnMessage &lt;&lt; &quot;'\\n&quot;; } return 0;} cmake 1234567891011121314151617181920212223242526272829303132333435cmake_minimum_required(VERSION 2.8)project(helloworld)set(CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -pthread -std=c++0x&quot;)include_directories( /home/helianthus/dev_tools/helloworld/src-gen /home/helianthus/dev_tools/capicxx-core-runtime-3.2.0/include /home/helianthus/dev_tools/capicxx-someip-runtime-3.2.0/include /home/helianthus/dev_tools/vsomeip-3.1.20.3/interface)link_directories( /home/helianthus/dev_tools/capicxx-core-runtime-3.2.0/build /home/helianthus/dev_tools/capicxx-someip-runtime-3.2.0/build /home/helianthus/dev_tools/vsomeip-3.1.20.3/build)add_executable(HelloWorldClient /home/helianthus/dev_tools/helloworld/HelloWorldClient.cpp /home/helianthus/dev_tools/helloworld/src-gen/v1/commonapi/HelloWorldSomeIPProxy.cpp /home/helianthus/dev_tools/helloworld/src-gen/v1/commonapi/HelloWorldSomeIPDeployment.cpp)target_link_libraries(HelloWorldClient CommonAPI CommonAPI-SomeIP vsomeip3)add_executable(HelloWorldService /home/helianthus/dev_tools/helloworld/HelloWorldService.cpp /home/helianthus/dev_tools/helloworld/HelloWorldStubImpl.cpp /home/helianthus/dev_tools/helloworld/src-gen/v1/commonapi/HelloWorldSomeIPStubAdapter.cpp /home/helianthus/dev_tools/helloworld/src-gen/v1/commonapi/HelloWorldStubDefault.hpp /home/helianthus/dev_tools/helloworld/src-gen/v1/commonapi/HelloWorldSomeIPDeployment.cpp)target_link_libraries(HelloWorldService CommonAPI CommonAPI-SomeIP vsomeip3) 踩的几个坑 fidl 文件高版本有变动 ～～define org.genivi.commonapi.someip.deployment for provider MyService {～～应该为 define org.genivi.commonapi.someip.deployment for provider as MyService { sudo ldconfig 会报 Configuration module could not be loaded! 其实是动态库的问题 vsomeip ld 找不到，高版本 cmake 要链接 vsomeip3","link":"/2022/04/06/ethernet/some-ip/capi/"},{"title":"C++ 中 RVO 和 NRVO 优化是什么？","text":"本文主要介绍 RVO 和 NRVO 在 C++ 的使用，为了解决了什么历史遗留问题？如何配合写出高效率的代码？ @love1angel 众所周知，RVO 和 NRVO 是在 C++ 11 之前编译器就提供的一种优化方式。并在 C++ 17 写入标准，作为编译器默认优化方式。 RVO 全称 return value optimization 返回值优化，NRVO 全称 named return value optimization 具名对象返回值优化。旨在当函数返回值为 T 类型时候，优化拷贝的消耗或者减少调用构造函数和拷贝构造函数的次数，NRVO 特指具名对象的 RVO 优化方式。","link":"/2024/05/02/languages/cpp/optimize/RVO/"},{"title":"pmr","text":"C++ 17 引入了内存相关的一系列可重写的 API。 在头文件 memory_resource 中。命名空间在 std::pmr:: ，目的在于 池化内存分配，减少频繁系统调用分配或释放内存，带来的性能损失 与已有 std 中的 allocator, container 结合，方便使用者自定义相关的内存分配策略类 特殊的使用场景：内存分配效率敏感、需要禁用内存分配。如因功能安全需要，自动驾驶代码禁止动态内存分配 标准库的主要结构如下 memory_resource 为分配释放内存的管理类，allocator 和类型相关，向 memory_resource 索取内存，因此构造 allocator 时候需要传入 upstream 即 memory_resource 的指针 标准库实现的内存分配类 std::pmr::monotonic_buffer_resource std::pmr::unsynchronized_pool_resource std::pmr::synchronized_pool_resource 获取默认的 new delete 内存分配策略，继承自 memory_resource。作为基准测试（clang++ 下为 __new_delete_memory_resource_imp）std::pmr::new_delete_resource() 分配内存调用 allocate 会直接抛出异常 std::bad_alloc()，通常用来禁止向 upstream 索要内存，从而禁止从默认的内存分配类索取内存std::pmr::null_memory_resource() 获取默认的内存分配策略类，不修改则为 new_delete_resourcestd::pmr::get_default_resource() 设置默认的内存分配策略类std::pmr::set_default_resource(memory_resource*) std 库封装的接口封装了 polymorphic_allocator 满足了 std 容器中需要满足的条件，如定义了 value_type，operaotr== 比较两个分配器是否相等。 封装了一些数据结构，如std::pmr::vector&lt;T&gt; 实际上是 std::list&lt;T, std::pmr::polymorphic_allocator&lt;T&gt;&gt; 这时候可以直接给他传入你的 buf, std::pmr::list{&amp;upstream}; upstream 即 memory_resource 实现类，upstream 会传递给 allocator 测试计时函数 12345678910template &lt;typename F, typename... Args&gt;void calc(F f, Args&amp;&amp;... args){ auto before = std::chrono::steady_clock::now(); f(std::forward&lt;Args&gt;(args)...); auto after = std::chrono::steady_clock::now(); std::chrono::duration&lt;double&gt; duration = after - before; std::cout &lt;&lt; duration &lt;&lt; std::endl;} 优化 list 12345678910111213141516171819202122232425262728293031std::array&lt;std::byte, 65536 * 24&gt; buf;int main(){ auto list = [] { std::list&lt;int&gt; list; for (int i { 0 }; i &lt; 65536; ++i) { list.push_back(i); } }; calc(list); auto pmr_list = [] { std::pmr::monotonic_buffer_resource resouce { buf.data(), buf.size() }; std::pmr::list&lt;int&gt; list { &amp;resouce }; for (int i { 0 }; i &lt; 65536; ++i) { list.push_back(i); } }; calc(pmr_list); auto vector = [] { std::vector&lt;int&gt; list; for (int i { 0 }; i &lt; 65536; ++i) { list.push_back(i); } }; calc(vector); return 0;} 0.00803458s0.00369133s0.00206471s 注意点如果用 set_default_resource 修改了默认的分配池，该 memory_resource 的生命期需要注意 实现解析，以 clang++ 为例monotonic_buffer_resource 是一个链表，每个节点是单调递减的 如果用户指定 buf，则对 buf 的管理类似上图，但是没有 footer，直到 cur 减少到达 start 没有指定 buf，则从 upstream 分配上图的 chunk + footer 块 2 倍指数级申请新的 chunk do_deallocate 不做任何动作，在析构函数里一次性 release 所有 chunk。适用于需要不停分配，但一次性释放的场景，线程不安全 unsynchronized_pool_resource 12__adhoc_pool __adhoc_pool_;__fixed_pool* __fixed_pools_; 其中主要实现了 adhoc pool，adhoc pool 主要是和 upstream 交流。申请超大内存时，会由 upstream 分配释放，小内存则会提供内部满足容量中最小的 fixed pool fixed pools 在首次分配时，会构造内存相邻的多个 fixed pool 指针，可以对请求的内存容量求 log2() 得到下标（2^n 就是该 fixed pool 的容量），进行偏移访问，从而可用的 fixed pool 链表 释放内存时，超大内存由 upstream 申请的，交由 upstream 释放。fixed pool 管理的只会添加到给该容量的 fixed pool 链表中，等待下一次使用。fixed pool 实现类似上面 chunk 和 footer，但是没有 cur。 可以指定 pool options，largest_required_pool_block 求对数后得到 fixed pool 个数， max_blocks_per_chunk 指的 fixed pool 的最大容量 synchronized_pool_resource 在开启多线程情况下，对 unsynchronized_pool_resource 封装了一层锁","link":"/2024/05/22/languages/cpp/optimize/pmr/"},{"title":"mangle","text":"demanglegcc compile 12# void test(int i)c++filt -n &lt;_Z4testi&gt;","link":"/2024/06/06/languages/cpp/realize/mangle/"},{"title":"std::move 到底做了什么？C++ 移动到底是什么？move 后的对象还可以使用吗？","text":"最近几天听到了一些对 C++ 不太对的看法，如下： move 后的对象不能用了 因为 move 移动了 C++ 对象的所有权，所以原本的对象不能再使用了 函数返回值 T 类型时候 return std::move(T {}); 本文暂时不考虑 pod 类型，pod 类型的做法通常直接进行拷贝。所以基于 class T 类型进行讨论： move 的实现强制转化成了 &amp;&amp; 类型 移动函数为什么要调用 std::move，因为需要你强制转为 &amp;&amp; 类型，调用移动相关的函数。 但是请注意，C++ 20 前的定义是这样，这就意味着如果你不加上 move 函数，则会调用拷贝相关的函数。然而 C++ 20 修改了标准，更符合直觉的调用 所有权是什么？这是书的作者为了易于读者理解而引入的概念，本质 C++ 没有这个概念，强烈依赖于 class T 中移动函数的实现。 例如 C++ 标准库中的大部分类类型，都支持 move 后的对象赋值后重新使用。这和 Rust 语言有本质的区别，可以认为这是 C++ 的一种设计哲学，为了减少系统调用分配内存的消耗。","link":"/2024/05/02/languages/cpp/realize/move/"},{"title":"C++ 左值引用和右值引用的原理","text":"不少 C++ 书上对于引用的描述是这样的： 引用为对象起了一个别名，当操作引用时候就像在操作引用绑定的对象。 这似乎将引用说的很高深莫测，然而引用不过是一种 C++ 相较于 C 语言的语法糖。本文简单介绍一下引用（左值引用）和右值引用的原理 让我们先来回顾一下 C 语言是如何传递操作对象的，C 语言在函数中要么就是指针传地址，要么就是浅拷贝。但是一般都是传指针，原因如下 直接传递一般比较耗时，C 编译器不会强制执行 RVO 这种优化 很容易犯错的一个 bug 是在拷贝后以后会修改形参并不会影响到实参。 C++ 引用的的出现，为我们解决的就是上面两个问题，是 C++ 相比于 C 提供的语言层面的语法糖。那么引用（左值引用）和 C++11 新出的右值引用的原理是什么呢？ 先说结论：引用和右值引用本质上都是指针，区别在于引用指向的可访问地址的对象，右值引用则指向匿名对象的地址。 让我们进入 compiler explorer 从汇编的角度来进行理解C++ 左值引用，右值引用 x86_64 gcc 12.2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182int square(int num) {// 函数序言square(int): push rbp mov rbp, rsp mov DWORD PTR [rbp-84], edi int a = 100; mov DWORD PTR [rbp-68], 100 int *p = &amp;a; lea rax, [rbp-68] mov QWORD PTR [rbp-8], rax int *p2 = nullptr; mov QWORD PTR [rbp-16], 0 int *p3;// none int &amp;ref = a; lea rax, [rbp-68] mov QWORD PTR [rbp-24], rax int b = ref; mov rax, QWORD PTR [rbp-24] mov eax, DWORD PTR [rax] mov DWORD PTR [rbp-28], eax ref = 20; mov rax, QWORD PTR [rbp-24] mov DWORD PTR [rax], 20 *p = 20; mov rax, QWORD PTR [rbp-8] mov DWORD PTR [rax], 20 int c = a; mov eax, DWORD PTR [rbp-68] mov DWORD PTR [rbp-32], eax int d = *p; mov rax, QWORD PTR [rbp-8] mov eax, DWORD PTR [rax] mov DWORD PTR [rbp-36], eax int &amp;&amp;r1 = 3;// 右值和左值一样也是指针地址，右值先做了拷贝，指向栈上 xvalue mov DWORD PTR [rbp-72], 3 lea rax, [rbp-72] mov QWORD PTR [rbp-48], rax int &amp;&amp;r2 = 10; mov DWORD PTR [rbp-76], 10 lea rax, [rbp-76] mov QWORD PTR [rbp-56], rax// 取地址，拿值，进行拷贝 r2 = r1; mov rax, QWORD PTR [rbp-48] mov edx, DWORD PTR [rax] mov rax, QWORD PTR [rbp-56] mov DWORD PTR [rax], edx// 左值可以直接取值，进行拷贝// 但右值引用无法用左值初始化，左值是直接拿值，那是bind的是右值，自相矛盾// 否则所有权无法判断，因为右值要先取地址，相同的地址 r2 = a; mov edx, DWORD PTR [rbp-68] mov rax, QWORD PTR [rbp-56] mov DWORD PTR [rax], edx// 直接拷贝了地址 int &amp;&amp;r3 = static_cast&lt;int &amp;&amp;&gt;(r1); mov rax, QWORD PTR [rbp-48] mov QWORD PTR [rbp-64], rax// 总结：左值和右值，对于指针在汇编看来没有区别，但是指针不强制要求存地址，左右值强制要求存地址// 右值会拷贝一次 xvalue，move 算法更像是改变的是编译器的限制 return 0; mov eax, 0 pop rbp ret}","link":"/2024/05/02/languages/cpp/realize/reference/"},{"title":"Asan","text":"","link":"/2022/08/20/languages/cpp/tools/Asan/"},{"title":"CMake","text":"cmake cheatsheet 命令行指定set(CMAKE_C_COMPILER /usr/bin/clang CACHE PATH “” FORCE)set(CMAKE_CXX_COMPILER /usr/bin/clang++ CACHE PATH “” FORCE) cmake -S . -B build -DCMAKE_CXX_COMPILER=/opt/homebrew/opt/llvm/bin/clang++ -DCMAKE_CXX_FLAGS=”-I/usr/local/bin -I/opt/homebrew/opt/llvm/include” -DCMAKE_EXE_LINKER_FLAGS=”-L/opt/homebrew/opt/llvm/lib -lpthread”","link":"/2022/04/13/languages/cpp/tools/CMake/"},{"title":"GTest","text":"examplehttps://cmake.org/cmake/help/latest/module/FetchContent.html https://cmake.org/cmake/help/git-stage/module/GoogleTest.html xUnit architectureInternational Software Testing Qualifications Board ctest 是 命令 123$ cmake -S . -B build$ cmake --build build$ cd build &amp;&amp; ctest Test Google 以前用来代表 test case 的术语 Test Case TEST() 代表 test case, Exercise a particular program path with specific input values and verify the results Test Suite Google 以前吧关联的测试用例叫 test case, 现在逐步采用 suite API refactor，deprecate 老的 API，A test suite contains one or many tests. assertion 三种结果，成功，非致命性错误(nonfatal failure)，致命性错误(fatal failure)，本质是函数测试崩溃或 expect 错误会失败 ASSERT_* 会产生致命性错误，中止当前的函数往下走，EXPECT_* 则不会产生致命性错误，还会继续走，一般使用 expect 来发现更多错误，没有意义往下走使用 assert assert 会直接返回，所以不执行 clean-up 代码，会导致泄漏，如果发生 heap check error 的时候，要考虑是否是 assert 导致的Since a failed ASSERT_* returns from the current function immediately, possibly skipping clean-up code that comes after it, it may cause a space leak. Depending on the nature of the leak, it may or may not be worth fixing - so keep this in mind if you get a heap checker error in addition to assertion errors. 自定义 log ostream，会被自动转为 UTF-8 编码 ASSERT_EQ(x.size(), y.size()) &lt;&lt; “Vectors x and y are of unequal length”; TEST(TestSuiteName, TestName) { … test body …}有问题就会失败 测试全名是 suite + test，两个名字不应该加下划线，全名是 identifier，相同的第一个名字应该相同","link":"/2022/04/11/languages/cpp/tools/GTest/"},{"title":"clang-format tool usage","text":"clang-format tools cheat sheet, this tool aim at keep code style consistent auto check and format code docshttps://clang.llvm.org/docs/ClangFormat.html download12# macbrew install llvm usage1234567891011121314# generate style file .clang-format, style can be [gnu, llvm, google, Mozilla, WebKit]clang-format -style=WebKit -dump-config &gt; .clang-format# modify file directlyclang-format -i main.cpp# modify git current staged changesgit clang-format# modify most recently git commitgit clang-format HEAD~1# in CI compareclang-format --diff &lt;before commit&gt; &lt;after commit&gt;","link":"/2022/08/20/languages/cpp/tools/clang-format/"},{"title":"clang-tidy","text":"","link":"/2022/08/20/languages/cpp/tools/clang-tidy/"},{"title":"valgrind","text":"","link":"/2022/08/20/languages/cpp/tools/valgrind/"}],"tags":[{"name":"done","slug":"done","link":"/tags/done/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"midware","slug":"midware","link":"/tags/midware/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"llvm","slug":"llvm","link":"/tags/llvm/"}],"categories":[{"name":"terminology","slug":"terminology","link":"/categories/terminology/"},{"name":"gdb","slug":"gdb","link":"/categories/gdb/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"tools","slug":"tools","link":"/categories/tools/"},{"name":"ethernet","slug":"ethernet","link":"/categories/ethernet/"},{"name":"languages","slug":"languages","link":"/categories/languages/"},{"name":"some&#x2F;ip","slug":"ethernet/some-ip","link":"/categories/ethernet/some-ip/"},{"name":"cpp","slug":"languages/cpp","link":"/categories/languages/cpp/"},{"name":"tools","slug":"languages/cpp/tools","link":"/categories/languages/cpp/tools/"},{"name":"optimize","slug":"languages/cpp/optimize","link":"/categories/languages/cpp/optimize/"},{"name":"realize","slug":"languages/cpp/realize","link":"/categories/languages/cpp/realize/"}],"pages":[{"title":"about","text":"I was born in 1999, graduated from 2017 ~ 2021 2014 ~ 2017 Currently, I’m a C++ developer. FocusingDeep in system.","link":"/about/index.html"}]}